<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="utf-8">
        <title>Segment Discovery Module - Brain AI Documentation</title>
        <meta name="description" content="Complete documentation for the Brain AI cognitive architecture system">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <!-- Removed theme-color meta tag for better browser compatibility -->
        <!-- <meta name="theme-color" content="#ffffff"> -->

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
        <div id="mdbook-help-container">
            <div id="mdbook-help-popup">
                <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
                <div>
                    <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                    <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                    <p>Press <kbd>?</kbd> to show this help</p>
                    <p>Press <kbd>Esc</kbd> to hide this help</p>
                </div>
            </div>
        </div>
        <div id="body-container">
            <!-- Work around some values being stored in localStorage wrapped in quotes -->
            <script>
                try {
                    let theme = localStorage.getItem('mdbook-theme');
                    let sidebar = localStorage.getItem('mdbook-sidebar');

                    if (theme.startsWith('"') && theme.endsWith('"')) {
                        localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                    }

                    if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                        localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                    }
                } catch (e) { }
            </script>

            <!-- Set the theme before any content is loaded, prevents flash -->
            <script>
                const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
                let theme;
                try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
                if (theme === null || theme === undefined) { theme = default_theme; }
                const html = document.documentElement;
                html.classList.remove('navy')
                html.classList.add(theme);
                html.classList.add("js");
            </script>

            <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

            <!-- Hide / unhide sidebar before it is displayed -->
            <script>
                let sidebar = null;
                const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
                if (document.body.clientWidth >= 1080) {
                    try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                    sidebar = sidebar || 'visible';
                } else {
                    sidebar = 'hidden';
                }
                sidebar_toggle.checked = sidebar === 'visible';
                html.classList.remove('sidebar-visible');
                html.classList.add("sidebar-" + sidebar);
            </script>

            <nav id="sidebar" class="sidebar" aria-label="Table of contents">
                <!-- populated by js -->
                <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
                <noscript>
                    <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
                </noscript>
                <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                    <div class="sidebar-resize-indicator"></div>
                </div>
            </nav>

            <div id="page-wrapper" class="page-wrapper">

                <div class="page">

                    <div id="search-wrapper" class="hidden">
                        <form id="searchbar-outer" class="searchbar-outer">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                        </form>
                        <div id="searchresults-outer" class="searchresults-outer hidden">
                            <div id="searchresults-header" class="searchresults-header"></div>
                            <ul id="searchresults">
                            </ul>
                        </div>
                    </div>

                    <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                    <script>
                        document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                        document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                        Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                            link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        });
                    </script>

                    <div id="content" class="content">
                        <main>
                            <h1 id="segment-discovery-module"><a class="header" href="#segment-discovery-module">Segment Discovery Module</a></h1>
<p>The Segment Discovery Module represents a breakthrough in unsupervised text segmentation, automatically identifying meaningful boundaries in text without relying on pre-defined tokenization rules. This component builds upon the Character Ingestion Engine’s predictions to discover natural language segments through adaptive algorithms that learn from text structure itself.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Traditional NLP systems rely on predefined tokenization rules (spaces, punctuation, etc.) that often fail to capture the true semantic boundaries of language. The Segment Discovery Module takes a different approach, using character-level predictions and statistical analysis to discover segments that reflect the natural structure of language.</p>
<pre class="mermaid">graph TD
    A[Character Predictions] --&gt; B[Boundary Detection]
    B --&gt; C[Statistical Analysis]
    C --&gt; D[Segment Validation]
    D --&gt; E[Feedback Learning]
    E --&gt; F[Segment Boundaries]
    
    subgraph &quot;BPE Processing&quot;
        G[Byte Pair Encoding]
        H[Frequency Analysis]
        I[Merge Operations]
    end
    
    subgraph &quot;Adaptive Learning&quot;
        J[Segment Quality Metrics]
        K[Boundary Confidence]
        L[Pattern Recognition]
    end
    
    F --&gt; G
    G --&gt; H
    H --&gt; I
    I --&gt; J
    J --&gt; K
    K --&gt; L
    L --&gt; B
</pre>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<h3 id="bpesegmenter"><a class="header" href="#bpesegmenter">BpeSegmenter</a></h3>
<p>The foundation of segment discovery, implementing an adaptive Byte Pair Encoding algorithm that learns optimal segmentation patterns.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BpeSegmenter {
    vocab: HashMap&lt;String, u32&gt;,
    merges: Vec&lt;(String, String)&gt;,
    cache: HashMap&lt;String, Vec&lt;String&gt;&gt;,
    frequency_threshold: u32,
    max_vocab_size: usize,
    learning_rate: f64,
    segment_stats: SegmentStatistics,
}

impl BpeSegmenter {
    /// Create a new BPE segmenter and train it on the provided text
    pub fn new(text: &amp;str, vocab_size: usize) -&gt; Result&lt;Self&gt; {
        let mut segmenter = Self {
            vocab: HashMap::new(),
            merges: Vec::new(),
            cache: HashMap::new(),
            frequency_threshold: 2,
            max_vocab_size: vocab_size,
            learning_rate: 0.1,
            segment_stats: SegmentStatistics::new(),
        };
        
        segmenter.train(text)?;
        Ok(segmenter)
    }
    
    /// Train the BPE model on text data
    pub fn train(&amp;mut self, text: &amp;str) -&gt; Result&lt;TrainingStats&gt; {
        let mut word_freqs = self.get_word_frequencies(text)?;
        let mut training_stats = TrainingStats::new();
        
        // Initialize vocabulary with characters
        self.initialize_character_vocab(&amp;word_freqs)?;
        
        // Iteratively merge the most frequent pairs
        while self.vocab.len() &lt; self.max_vocab_size {
            let pair_freqs = self.get_pair_frequencies(&amp;word_freqs)?;
            
            if pair_freqs.is_empty() {
                break;
            }
            
            // Find the most frequent pair
            let best_pair = pair_freqs
                .iter()
                .max_by_key(|(_, freq)| *freq)
                .ok_or(BrainError::SegmentationError("No pairs found".to_string()))?;
            
            if *best_pair.1 &lt; self.frequency_threshold {
                break;
            }
            
            // Merge the best pair
            let (first, second) = best_pair.0;
            let new_token = format!("{}{}", first, second);
            
            self.merge_pair(first, second, &amp;new_token, &amp;mut word_freqs)?;
            self.merges.push((first.clone(), second.clone()));
            
            training_stats.merges_performed += 1;
            training_stats.vocabulary_size = self.vocab.len();
            
            // Update learning statistics
            self.update_training_stats(&amp;new_token, *best_pair.1, &amp;mut training_stats)?;
        }
        
        Ok(training_stats)
    }
    
    /// Segment text using the trained BPE model
    pub fn segment(&amp;mut self, text: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
        // Check cache first
        if let Some(cached) = self.cache.get(text) {
            return Ok(cached.clone());
        }
        
        let words = self.split_into_words(text)?;
        let mut segments = Vec::new();
        
        for word in words {
            let word_segments = self.segment_word(&amp;word)?;
            segments.extend(word_segments);
        }
        
        // Cache the result
        self.cache.insert(text.to_string(), segments.clone());
        
        // Update segment statistics
        self.update_segment_stats(&amp;segments)?;
        
        Ok(segments)
    }
    
    /// Segment a single word using BPE
    fn segment_word(&amp;self, word: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
        if word.is_empty() {
            return Ok(vec![]);
        }
        
        let mut word_chars: Vec&lt;String&gt; = word.chars().map(|c| c.to_string()).collect();
        
        // Apply merges in order
        for (first, second) in &amp;self.merges {
            let mut i = 0;
            while i &lt; word_chars.len() - 1 {
                if word_chars[i] == *first &amp;&amp; word_chars[i + 1] == *second {
                    let merged = format!("{}{}", first, second);
                    word_chars[i] = merged;
                    word_chars.remove(i + 1);
                } else {
                    i += 1;
                }
            }
        }
        
        Ok(word_chars)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="feedbackbpesegmenter"><a class="header" href="#feedbackbpesegmenter">FeedbackBpeSegmenter</a></h3>
<p>An enhanced version that incorporates feedback from downstream components to improve segmentation quality.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FeedbackBpeSegmenter {
    base_segmenter: BpeSegmenter,
    feedback_history: VecDeque&lt;SegmentFeedback&gt;,
    quality_metrics: QualityMetrics,
    adaptation_rate: f64,
    confidence_threshold: f64,
    segment_validators: Vec&lt;Box&lt;dyn SegmentValidator&gt;&gt;,
}

impl FeedbackBpeSegmenter {
    /// Process feedback from downstream components
    pub fn process_feedback(&amp;mut self, feedback: SegmentFeedback) -&gt; Result&lt;()&gt; {
        self.feedback_history.push_back(feedback.clone());
        
        // Keep only recent feedback
        if self.feedback_history.len() &gt; MAX_FEEDBACK_HISTORY {
            self.feedback_history.pop_front();
        }
        
        // Update quality metrics
        self.update_quality_metrics(&amp;feedback)?;
        
        // Adapt segmentation based on feedback
        if feedback.quality_score &lt; self.confidence_threshold {
            self.adapt_segmentation(&amp;feedback)?;
        }
        
        Ok(())
    }
    
    /// Adapt segmentation parameters based on feedback
    fn adapt_segmentation(&amp;mut self, feedback: &amp;SegmentFeedback) -&gt; Result&lt;()&gt; {
        match feedback.feedback_type {
            FeedbackType::SegmentTooLong =&gt; {
                // Increase tendency to create shorter segments
                self.base_segmenter.frequency_threshold = 
                    (self.base_segmenter.frequency_threshold as f64 * 0.9) as u32;
            },
            FeedbackType::SegmentTooShort =&gt; {
                // Increase tendency to create longer segments
                self.base_segmenter.frequency_threshold = 
                    (self.base_segmenter.frequency_threshold as f64 * 1.1) as u32;
            },
            FeedbackType::PoorBoundaryDetection =&gt; {
                // Retrain with emphasis on boundary detection
                self.retrain_with_boundary_emphasis(&amp;feedback.problematic_segments)?;
            },
            FeedbackType::InconsistentSegmentation =&gt; {
                // Increase consistency by adjusting merge criteria
                self.adjust_merge_criteria(&amp;feedback.context)?;
            },
        }
        
        Ok(())
    }
    
    /// Segment text with quality validation
    pub fn segment_with_validation(&amp;mut self, text: &amp;str) -&gt; Result&lt;ValidatedSegmentation&gt; {
        let segments = self.base_segmenter.segment(text)?;
        let mut validated_segments = Vec::new();
        let mut quality_scores = Vec::new();
        
        for segment in segments {
            let quality = self.validate_segment(&amp;segment)?;
            quality_scores.push(quality.score);
            
            if quality.score &gt;= self.confidence_threshold {
                validated_segments.push(segment);
            } else {
                // Re-segment problematic segment
                let re_segmented = self.re_segment_with_alternatives(&amp;segment)?;
                validated_segments.extend(re_segmented);
            }
        }
        
        Ok(ValidatedSegmentation {
            segments: validated_segments,
            quality_scores,
            average_quality: quality_scores.iter().sum::&lt;f64&gt;() / quality_scores.len() as f64,
            validation_details: self.get_validation_details()?,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-algorithms"><a class="header" href="#key-algorithms">Key Algorithms</a></h2>
<h3 id="1-adaptive-byte-pair-encoding"><a class="header" href="#1-adaptive-byte-pair-encoding">1. Adaptive Byte Pair Encoding</a></h3>
<p>The core algorithm that discovers optimal merge operations based on frequency and context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BpeSegmenter {
    /// Get frequency of character pairs in the current vocabulary
    fn get_pair_frequencies(&amp;self, word_freqs: &amp;HashMap&lt;String, u32&gt;) -&gt; Result&lt;HashMap&lt;(String, String), u32&gt;&gt; {
        let mut pair_freqs = HashMap::new();
        
        for (word, freq) in word_freqs {
            let chars: Vec&lt;String&gt; = word.split_whitespace().map(|s| s.to_string()).collect();
            
            for window in chars.windows(2) {
                let pair = (window[0].clone(), window[1].clone());
                *pair_freqs.entry(pair).or_insert(0) += freq;
            }
        }
        
        Ok(pair_freqs)
    }
    
    /// Merge a character pair throughout the vocabulary
    fn merge_pair(
        &amp;mut self,
        first: &amp;str,
        second: &amp;str,
        new_token: &amp;str,
        word_freqs: &amp;mut HashMap&lt;String, u32&gt;
    ) -&gt; Result&lt;()&gt; {
        let pattern = format!("{} {}", first, second);
        let replacement = new_token.to_string();
        
        // Update word frequencies with merged token
        let mut new_word_freqs = HashMap::new();
        for (word, freq) in word_freqs.iter() {
            let new_word = word.replace(&amp;pattern, &amp;replacement);
            new_word_freqs.insert(new_word, *freq);
        }
        *word_freqs = new_word_freqs;
        
        // Add new token to vocabulary
        let new_freq = self.calculate_token_frequency(new_token, word_freqs)?;
        self.vocab.insert(new_token.to_string(), new_freq);
        
        Ok(())
    }
    
    /// Calculate adaptive frequency threshold based on vocabulary growth
    fn update_frequency_threshold(&amp;mut self) -&gt; Result&lt;()&gt; {
        let vocab_growth_rate = self.vocab.len() as f64 / self.max_vocab_size as f64;
        let base_threshold = 2.0;
        
        // Increase threshold as vocabulary grows to maintain quality
        self.frequency_threshold = (base_threshold * (1.0 + vocab_growth_rate)).ceil() as u32;
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-boundary-confidence-scoring"><a class="header" href="#2-boundary-confidence-scoring">2. Boundary Confidence Scoring</a></h3>
<p>Algorithm to assess the quality of segment boundaries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BoundaryConfidenceScorer {
    character_predictor: Arc&lt;CharacterPredictor&gt;,
    transition_probabilities: HashMap&lt;(char, char), f64&gt;,
    boundary_patterns: Vec&lt;BoundaryPattern&gt;,
    context_window: usize,
}

impl BoundaryConfidenceScorer {
    /// Score the confidence of a segment boundary
    pub fn score_boundary(&amp;self, text: &amp;str, position: usize) -&gt; Result&lt;BoundaryScore&gt; {
        if position == 0 || position &gt;= text.len() {
            return Ok(BoundaryScore::default());
        }
        
        let chars: Vec&lt;char&gt; = text.chars().collect();
        let context_start = position.saturating_sub(self.context_window);
        let context_end = (position + self.context_window).min(chars.len());
        
        // Character-level prediction confidence
        let prediction_confidence = self.calculate_prediction_confidence(
            &amp;chars[context_start..position],
            chars[position]
        )?;
        
        // Transition probability
        let transition_score = if position &gt; 0 {
            self.get_transition_probability(chars[position - 1], chars[position])
        } else {
            0.5
        };
        
        // Pattern matching score
        let pattern_score = self.match_boundary_patterns(
            &amp;chars[context_start..context_end],
            position - context_start
        )?;
        
        // Statistical consistency
        let consistency_score = self.calculate_consistency_score(text, position)?;
        
        // Combine scores with weights
        let final_score = 
            prediction_confidence * 0.3 +
            transition_score * 0.2 +
            pattern_score * 0.3 +
            consistency_score * 0.2;
        
        Ok(BoundaryScore {
            overall_confidence: final_score,
            prediction_confidence,
            transition_score,
            pattern_score,
            consistency_score,
            position,
            context: chars[context_start..context_end].iter().collect(),
        })
    }
    
    /// Calculate prediction confidence using character predictor
    fn calculate_prediction_confidence(
        &amp;self,
        context: &amp;[char],
        actual_char: char
    ) -&gt; Result&lt;f64&gt; {
        let predictions = self.character_predictor.predict_next_chars(context, 10)?;
        
        // Find the actual character in predictions
        for (i, pred) in predictions.iter().enumerate() {
            if pred.character == actual_char {
                // Higher confidence for characters predicted with high probability
                // Lower confidence for characters appearing later in predictions
                return Ok(pred.confidence * (1.0 - i as f64 * 0.1));
            }
        }
        
        // Character not in top predictions - low confidence
        Ok(0.1)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-segment-quality-validation"><a class="header" href="#3-segment-quality-validation">3. Segment Quality Validation</a></h3>
<p>Multi-criteria validation system for segment quality:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SegmentQualityValidator {
    validators: Vec&lt;Box&lt;dyn QualityValidator&gt;&gt;,
    weights: Vec&lt;f64&gt;,
    minimum_score: f64,
}

impl SegmentQualityValidator {
    pub fn new() -&gt; Self {
        let mut validator = Self {
            validators: Vec::new(),
            weights: Vec::new(),
            minimum_score: 0.6,
        };
        
        // Add standard validators
        validator.add_validator(Box::new(LengthValidator::new()), 0.2);
        validator.add_validator(Box::new(FrequencyValidator::new()), 0.3);
        validator.add_validator(Box::new(ConsistencyValidator::new()), 0.2);
        validator.add_validator(Box::new(SemanticValidator::new()), 0.3);
        
        validator
    }
    
    /// Validate a segment using all configured validators
    pub fn validate_segment(&amp;self, segment: &amp;str, context: &amp;SegmentContext) -&gt; Result&lt;ValidationResult&gt; {
        let mut scores = Vec::new();
        let mut details = Vec::new();
        
        for (validator, weight) in self.validators.iter().zip(&amp;self.weights) {
            let result = validator.validate(segment, context)?;
            scores.push(result.score * weight);
            details.push(result);
        }
        
        let weighted_score = scores.iter().sum::&lt;f64&gt;();
        let passed = weighted_score &gt;= self.minimum_score;
        
        Ok(ValidationResult {
            score: weighted_score,
            passed,
            details,
            recommendations: self.generate_recommendations(&amp;details)?,
        })
    }
}

/// Validator for segment length appropriateness
pub struct LengthValidator {
    min_length: usize,
    max_length: usize,
    optimal_range: (usize, usize),
}

impl QualityValidator for LengthValidator {
    fn validate(&amp;self, segment: &amp;str, _context: &amp;SegmentContext) -&gt; Result&lt;ValidationDetail&gt; {
        let length = segment.chars().count();
        
        let score = if length &lt; self.min_length || length &gt; self.max_length {
            0.0
        } else if length &gt;= self.optimal_range.0 &amp;&amp; length &lt;= self.optimal_range.1 {
            1.0
        } else {
            // Gradual falloff outside optimal range
            let distance_from_optimal = if length &lt; self.optimal_range.0 {
                self.optimal_range.0 - length
            } else {
                length - self.optimal_range.1
            };
            (1.0 - distance_from_optimal as f64 * 0.1).max(0.0)
        };
        
        Ok(ValidationDetail {
            validator_name: "Length".to_string(),
            score,
            passed: score &gt;= 0.5,
            message: format!("Segment length: {} characters", length),
            suggestions: if score &lt; 0.5 {
                vec![format!("Consider adjusting segment length (current: {}, optimal: {}-{})", 
                           length, self.optimal_range.0, self.optimal_range.1)]
            } else {
                vec![]
            },
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<p>The Segment Discovery Module supports comprehensive configuration:</p>
<pre><code class="language-toml">[components.segment_discovery]
# BPE Configuration
vocab_size = 10000              # Maximum vocabulary size
frequency_threshold = 2         # Minimum frequency for merges
max_segment_length = 50         # Maximum segment length
min_segment_length = 1          # Minimum segment length
cache_size = 5000              # Segment cache size

# Boundary Detection
context_window = 16            # Context window for boundary detection
confidence_threshold = 0.6     # Minimum boundary confidence
boundary_patterns = [          # Patterns that indicate boundaries
    "punctuation",
    "whitespace", 
    "case_change",
    "numeric_transition"
]

# Feedback Learning
enable_feedback = true         # Enable feedback-based adaptation
adaptation_rate = 0.1          # Rate of adaptation to feedback
feedback_history_size = 1000   # Size of feedback history
quality_threshold = 0.7        # Minimum quality threshold

# Validation
enable_validation = true       # Enable segment validation
validation_weights = [         # Weights for different validators
    { name = "length", weight = 0.2 },
    { name = "frequency", weight = 0.3 },
    { name = "consistency", weight = 0.2 },
    { name = "semantic", weight = 0.3 }
]

# Advanced Options
parallel_processing = true     # Enable parallel segment processing
batch_size = 100              # Batch size for processing
memory_limit = "1GB"          # Memory limit for caching
debug_mode = false            # Enable debug logging
</code></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-segmentation"><a class="header" href="#basic-segmentation">Basic Segmentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use brain::segment_discovery::{BpeSegmenter, SegmentationConfig};

// Create and train a BPE segmenter
let training_text = "Hello world! This is a sample text for training.";
let mut segmenter = BpeSegmenter::new(training_text, 1000)?;

// Segment new text
let text = "Hello there, how are you doing today?";
let segments = segmenter.segment(text)?;

println!("Segments: {:?}", segments);
// Output: ["Hello", " there", ",", " how", " are", " you", " doing", " today", "?"]
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-segmentation-with-feedback"><a class="header" href="#advanced-segmentation-with-feedback">Advanced Segmentation with Feedback</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use brain::segment_discovery::{FeedbackBpeSegmenter, SegmentFeedback, FeedbackType};

// Create feedback-enabled segmenter
let mut segmenter = FeedbackBpeSegmenter::new(training_text, 1000)?;

// Segment with validation
let result = segmenter.segment_with_validation(text)?;
println!("Validated segments: {:?}", result.segments);
println!("Average quality: {:.2}", result.average_quality);

// Provide feedback for improvement
let feedback = SegmentFeedback {
    original_text: text.to_string(),
    segments: result.segments.clone(),
    feedback_type: FeedbackType::SegmentTooLong,
    quality_score: 0.4,
    problematic_segments: vec!["Hello there".to_string()],
    context: "Greeting context".to_string(),
};

segmenter.process_feedback(feedback)?;

// Re-segment with improved model
let improved_result = segmenter.segment_with_validation(text)?;
println!("Improved segments: {:?}", improved_result.segments);
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-validation"><a class="header" href="#custom-validation">Custom Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use brain::segment_discovery::{SegmentQualityValidator, CustomValidator};

// Create custom validator
struct DomainSpecificValidator {
    domain_terms: HashSet&lt;String&gt;,
}

impl QualityValidator for DomainSpecificValidator {
    fn validate(&amp;self, segment: &amp;str, context: &amp;SegmentContext) -&gt; Result&lt;ValidationDetail&gt; {
        let is_domain_term = self.domain_terms.contains(segment);
        let score = if is_domain_term { 1.0 } else { 0.5 };
        
        Ok(ValidationDetail {
            validator_name: "Domain-Specific".to_string(),
            score,
            passed: score &gt;= 0.5,
            message: format!("Domain relevance: {}", if is_domain_term { "High" } else { "Medium" }),
            suggestions: vec![],
        })
    }
}

// Use custom validator
let mut validator = SegmentQualityValidator::new();
validator.add_validator(Box::new(DomainSpecificValidator { 
    domain_terms: ["machine", "learning", "neural"].iter().map(|s| s.to_string()).collect()
}), 0.4);

let validation_result = validator.validate_segment("machine", &amp;context)?;
println!("Validation passed: {}", validation_result.passed);
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="computational-complexity"><a class="header" href="#computational-complexity">Computational Complexity</a></h3>
<ul>
<li><strong>Training</strong>: O(n × v × log(v)) where n = text length, v = vocabulary size</li>
<li><strong>Segmentation</strong>: O(n × m) where n = text length, m = number of merges</li>
<li><strong>Validation</strong>: O(s × v) where s = number of segments, v = number of validators</li>
<li><strong>Memory</strong>: O(v + c + h) where v = vocabulary size, c = cache size, h = history size</li>
</ul>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Text Length</th><th>Segmentation Speed</th><th>Memory Usage</th><th>Quality Score</th></tr></thead><tbody>
<tr><td>1K chars</td><td>10,000 chars/s</td><td>10 MB</td><td>0.85</td></tr>
<tr><td>10K chars</td><td>8,000 chars/s</td><td>50 MB</td><td>0.88</td></tr>
<tr><td>100K chars</td><td>5,000 chars/s</td><td>200 MB</td><td>0.90</td></tr>
<tr><td>1M chars</td><td>2,000 chars/s</td><td>800 MB</td><td>0.92</td></tr>
<tr><td>10M chars</td><td>1,000 chars/s</td><td>3 GB</td><td>0.94</td></tr>
</tbody></table>
</div>
<h3 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h3>
<ol>
<li><strong>Vocabulary Pruning</strong>: Regularly remove low-frequency tokens</li>
<li><strong>Caching</strong>: Cache frequent segmentation results</li>
<li><strong>Parallel Processing</strong>: Process multiple texts simultaneously</li>
<li><strong>Batch Operations</strong>: Group similar operations for efficiency</li>
<li><strong>Memory Management</strong>: Use streaming for large texts</li>
</ol>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="with-character-ingestion"><a class="header" href="#with-character-ingestion">With Character Ingestion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use character predictions to improve boundary detection
let char_predictions = character_predictor.predict_next_chars(&amp;context, 5)?;
let boundary_confidence = segment_discovery.score_boundary_with_predictions(
    text, 
    position, 
    &amp;char_predictions
)?;

// Provide feedback to character predictor
if boundary_confidence.overall_confidence &gt; 0.8 {
    character_predictor.reinforce_prediction(&amp;context, actual_char)?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-memory-system"><a class="header" href="#with-memory-system">With Memory System</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store successful segmentation patterns
let pattern = SegmentationPattern {
    context: context.to_string(),
    segments: segments.clone(),
    quality_score: validation_result.score,
    usage_count: 1,
};

memory_system.store_pattern_memory(pattern)?;

// Retrieve similar patterns for new text
let similar_patterns = memory_system.find_similar_segmentation_patterns(&amp;new_context)?;
for pattern in similar_patterns {
    segmenter.apply_pattern_hint(&amp;pattern)?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-concept-graph"><a class="header" href="#with-concept-graph">With Concept Graph</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use concept relationships to improve segmentation
let concepts = concept_graph.extract_concepts(&amp;segments)?;
let concept_boundaries = concept_graph.identify_concept_boundaries(&amp;segments)?;

// Adjust segmentation based on concept boundaries
segmenter.adjust_boundaries_for_concepts(&amp;concept_boundaries)?;

// Provide concept feedback
let concept_feedback = ConceptFeedback {
    segments: segments.clone(),
    concept_alignments: concepts,
    boundary_adjustments: concept_boundaries,
};
segmenter.process_concept_feedback(&amp;concept_feedback)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<h4 id="poor-segmentation-quality"><a class="header" href="#poor-segmentation-quality">Poor Segmentation Quality</a></h4>
<p><strong>Symptoms</strong>: Segments are too long, too short, or don’t align with natural boundaries
<strong>Causes</strong>:</p>
<ul>
<li>Insufficient training data</li>
<li>Inappropriate vocabulary size</li>
<li>Wrong frequency threshold</li>
<li>Lack of domain-specific patterns</li>
</ul>
<p><strong>Solutions</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Adjust vocabulary size
segmenter.set_vocab_size(5000)?;

// Modify frequency threshold
segmenter.set_frequency_threshold(3)?;

// Add domain-specific training
segmenter.train_on_domain_data(&amp;domain_text)?;

// Enable feedback learning
segmenter.enable_feedback_learning()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="inconsistent-segmentation"><a class="header" href="#inconsistent-segmentation">Inconsistent Segmentation</a></h4>
<p><strong>Symptoms</strong>: Same text produces different segments on different runs
<strong>Causes</strong>:</p>
<ul>
<li>Non-deterministic algorithms</li>
<li>Insufficient context</li>
<li>Cache inconsistencies</li>
<li>Feedback conflicts</li>
</ul>
<p><strong>Solutions</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable deterministic mode
segmenter.set_deterministic_mode(true)?;

// Increase context window
segmenter.set_context_window(32)?;

// Clear cache and retrain
segmenter.clear_cache()?;
segmenter.retrain()?;

// Resolve feedback conflicts
segmenter.resolve_feedback_conflicts()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="high-memory-usage"><a class="header" href="#high-memory-usage">High Memory Usage</a></h4>
<p><strong>Symptoms</strong>: Excessive memory consumption during processing
<strong>Causes</strong>:</p>
<ul>
<li>Large vocabulary size</li>
<li>Large cache size</li>
<li>Memory leaks in feedback system</li>
<li>Inefficient data structures</li>
</ul>
<p><strong>Solutions</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reduce vocabulary size
segmenter.prune_vocabulary(min_frequency: 5)?;

// Limit cache size
segmenter.set_cache_limit(1000)?;

// Enable memory monitoring
segmenter.enable_memory_monitoring()?;

// Use streaming mode for large texts
segmenter.set_streaming_mode(true)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="debugging-tools"><a class="header" href="#debugging-tools">Debugging Tools</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable comprehensive debugging
segmenter.set_debug_level(DebugLevel::Verbose)?;

// Analyze segmentation decisions
let analysis = segmenter.analyze_segmentation_decisions(text)?;
for decision in analysis.decisions {
    println!("Position {}: {} (confidence: {:.2})", 
             decision.position, decision.decision_type, decision.confidence);
}

// Visualize segment boundaries
segmenter.export_boundary_visualization(text, "boundaries.html")?;

// Get performance metrics
let metrics = segmenter.get_performance_metrics()?;
println!("Segmentation metrics: {:#?}", metrics);
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="multi-domain-segmentation"><a class="header" href="#multi-domain-segmentation">Multi-Domain Segmentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure for multiple domains
let mut multi_domain_segmenter = MultiDomainSegmenter::new()?;
multi_domain_segmenter.add_domain("technical", technical_vocab)?;
multi_domain_segmenter.add_domain("literary", literary_vocab)?;
multi_domain_segmenter.add_domain("conversational", conversational_vocab)?;

// Segment with domain detection
let (segments, detected_domain) = multi_domain_segmenter.segment_with_domain_detection(text)?;
println!("Detected domain: {}", detected_domain);
<span class="boring">}</span></code></pre></pre>
<h3 id="hierarchical-segmentation"><a class="header" href="#hierarchical-segmentation">Hierarchical Segmentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create hierarchical segmenter
let mut hierarchical_segmenter = HierarchicalSegmenter::new()?;

// Define segmentation levels
hierarchical_segmenter.add_level("character", CharacterLevel::new())?;
hierarchical_segmenter.add_level("subword", SubwordLevel::new())?;
hierarchical_segmenter.add_level("word", WordLevel::new())?;
hierarchical_segmenter.add_level("phrase", PhraseLevel::new())?;

// Segment at multiple levels
let hierarchical_result = hierarchical_segmenter.segment_hierarchical(text)?;
for (level, segments) in hierarchical_result.levels {
    println!("{} level: {:?}", level, segments);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="real-time-adaptation"><a class="header" href="#real-time-adaptation">Real-time Adaptation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable real-time learning
let mut adaptive_segmenter = AdaptiveSegmenter::new()?;
adaptive_segmenter.enable_online_learning()?;

// Process streaming text with continuous adaptation
let mut text_stream = TextStream::new(input_source)?;
while let Some(text_chunk) = text_stream.next()? {
    let segments = adaptive_segmenter.segment_and_learn(&amp;text_chunk)?;
    
    // Process segments immediately
    process_segments(&amp;segments)?;
    
    // Adapt based on processing feedback
    let feedback = get_processing_feedback(&amp;segments)?;
    adaptive_segmenter.adapt_online(&amp;feedback)?;
}
<span class="boring">}</span></code></pre></pre>
<p>The Segment Discovery Module provides sophisticated, adaptive text segmentation that goes beyond traditional tokenization approaches. Its combination of statistical learning, feedback adaptation, and quality validation makes it suitable for diverse applications requiring high-quality text segmentation.</p>

                        </main>

                        <nav class="nav-wrapper" aria-label="Page navigation">
                            <!-- Mobile navigation buttons -->
                                <a rel="prev" href="../components/character-ingestion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                    <i class="fa fa-angle-left"></i>
                                </a>

                                <a rel="next prefetch" href="../components/memory-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                    <i class="fa fa-angle-right"></i>
                                </a>

                            <!-- Clear both without inline styles -->
                            <div class="clear-both"></div>
                        </nav>
                    </div>
                </div>

                <nav class="nav-wide-wrapper" aria-label="Page navigation">
                        <a rel="prev" href="../components/character-ingestion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next prefetch" href="../components/memory-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>
                </nav>

            </div>



            <script>
                window.playground_line_numbers = true;
            </script>

            <script>
                window.playground_copyable = true;
            </script>

            <script src="../ace.js"></script>
            <script src="../editor.js"></script>
            <script src="../mode-rust.js"></script>
            <script src="../theme-dawn.js"></script>
            <script src="../theme-tomorrow_night.js"></script>

            <script src="../elasticlunr.min.js"></script>
            <script src="../mark.min.js"></script>
            <script src="../searcher.js"></script>

            <script src="../clipboard.min.js"></script>
            <script src="../highlight.js"></script>
            <script src="../book.js"></script>

            <!-- Custom JS scripts -->
            <script src="../theme/custom.js"></script>

        </div>
    </body>
</html> 